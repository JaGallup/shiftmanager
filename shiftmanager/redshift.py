#!/usr/bin/env python

from contextlib import closing, contextmanager
import itertools
import os
import random
import string
from subprocess import check_output

import psycopg2

# Redshift distribution styles
DISTSTYLES_BY_INDEX = {
    0: 'EVEN',
    1: 'KEY',
    8: 'ALL',
}

DB_HOSTS = {
    'prod': 'prod-data-pipeline.cuxrn97vbxid.us-east-1.redshift.amazonaws.com',
    'dev':  'dev-data-pipeline.cuxrn97vbxid.us-east-1.redshift.amazonaws.com',
}


class TableDefinitionStatement(object):
    """
    Container for pulling a table definition from Redshift and modifying it.
    """
    def __init__(self, conn, tablename,
                 distkey=None, sortkey=None, diststyle=None, owner=None):
        """
        Pulls creation commands for *tablename* from Redshift.

        The *conn* parameter should be a psycopg2 Connection object.

        The basic CREATE TABLE statement is generated by a call to the
        `pg_dump` executable. Current values of dist and sort keys are
        determined by queries to system tables.

        The other parameters, if set, will modify various properties
        of the table.
        """
        self.tablename = tablename

        output = check_output(['pg_dump', '--schema-only',
                               '--table', tablename,
                               'analytics'])
        lines = output.split('\n')
        self.sets = [line for line in lines
                     if line.startswith('SET ')]
        self.grants = [line for line in lines
                       if line.startswith('REVOKE ')
                       or line.startswith('GRANT ')]
        self.alters = [line for line in lines
                       if line.startswith('ALTER TABLE ')
                       and not line.startswith('ALTER TABLE ONLY')]
        if owner:
            self.alters.append('ALTER TABLE {0} OWNER to {1};'
                               .format(tablename, owner))
            self.grants.append('GRANT ALL ON TABLE {0} TO {1};'
                               .format(tablename, owner))
        create_start_index = [i for i, line in enumerate(lines)
                              if line.startswith('CREATE TABLE ')][0]
        create_end_index = [i for i, line in enumerate(lines)
                            if i > create_start_index
                            and line.startswith(');')][0]
        self.create_lines = lines[create_start_index:create_end_index]

        with closing(conn.cursor()) as cur:
            query_template = """
            SELECT \"column\" from pg_table_def
            WHERE tablename = '{0}'
            AND {1} = {2}
            """
            cur.execute(query_template.format(tablename, 'distkey', "'t'"))
            result = cur.fetchall()
            self.distkey = distkey or result and result[0][0] or None
            cur.execute(query_template.format(tablename, 'sortkey', "1"))
            result = cur.fetchall()
            self.sortkey = sortkey or result and result[0][0] or None

            query_template = """
            SELECT reldiststyle FROM pg_class
            WHERE relname = '{0}'
            """
            cur.execute(query_template.format(tablename))
            self.diststyle = (diststyle or
                              DISTSTYLES_BY_INDEX[cur.fetchone()[0]])

        if distkey and not diststyle:
            self.diststyle = 'KEY'
        if self.diststyle.upper() in ['ALL', 'EVEN']:
            self.distkey = None

    def definition(self):
        """
        Returns the full SQL code to recreate the table.
        """
        names = {
            'tablename': self.tablename,
            'oldtmp': 'temp_old_' + self.tablename,
            'newtmp': 'temp_new_' + self.tablename,
        }

        create_lines = self.create_lines[:]
        create_lines[0] = create_lines[0].replace(self.tablename, '{newtmp}')
        create_lines.append(") DISTSTYLE {0}".format(self.diststyle))
        if self.distkey:
            create_lines.append("  DISTKEY({0})".format(self.distkey))
        if self.sortkey:
            create_lines.append("  SORTKEY({0})".format(self.sortkey))
        create_lines[-1] += ';\n'

        all_lines = itertools.chain(
            # Alter the original table ASAP, so that it gets locked for
            # reads/writes outside the transaction.
            ["SET search_path = analytics, pg_catalog;\n"],
            ["ALTER TABLE {tablename} RENAME TO {oldtmp};"],
            create_lines,
            ["INSERT INTO {newtmp} (SELECT * FROM {oldtmp});"],
            ["ALTER TABLE {newtmp} RENAME TO {tablename};"],
            ["DROP TABLE {oldtmp};\n"],
            self.alters,
            [''],
            self.grants)

        return '\n'.join(all_lines).format(**names)


@contextmanager
def redshift_transaction(host, database='analytics', port=5439):
    host = _get_host(host)
    with closing(psycopg2.connect(host=host,
                                  database=database,
                                  port=port)) as conn:
        cur = conn.cursor()

        # Make sure we create tables in the analytics schema
        cur.execute("SET search_path = analytics")

        # Return the connection and cursor to the calling function
        yield conn, cur

        conn.commit()


def connect_from_env():
    """
    Return a psycopg2 connection based on environment variables.
    """
    return psycopg2.connect(
        host=os.environ['PGHOST'],
        database=os.environ.get('PGDATABASE', 'analytics'),
        port=int(os.environ.get('PGPORT', 5439)),
    )


def _get_host(host):
    if host in DB_HOSTS:
        return DB_HOSTS[host]
    return host


def random_password(length=64):
    """
    Return a strong and valid password for Redshift.

    Constraints:
     - 8 to 64 characters in length.
     - Must contain at least one uppercase letter, one lowercase letter,
       and one number.
     - Can use any printable ASCII characters (ASCII code 33 to 126)
       except ' (single quote), \" (double quote), \\, /, @, or space.
     - See http://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_USER.html

    """
    rand = random.SystemRandom()
    invalid_chars = r'''\/'"@ '''
    valid_chars_set = set(
        string.digits +
        string.letters +
        string.punctuation
    ) - set(invalid_chars)
    valid_chars = list(valid_chars_set)
    chars = [rand.choice(string.ascii_uppercase),
             rand.choice(string.ascii_lowercase),
             rand.choice(string.digits)]
    chars += [rand.choice(valid_chars) for x in xrange(length - 3)]
    rand.shuffle(chars)
    return ''.join(chars)


def create_user(host, username, password):
    """
    Create a new user account.
    """

    host = _get_host(host)

    conn = psycopg2.connect(
        host=host,
        database='analytics',
        port=5439,
    )

    cur = conn.cursor()

    cur.execute("""
    CREATE USER {0}
    PASSWORD '{1}'
    IN GROUP analyticsusers;
    ALTER USER {0}
    SET wlm_query_slot_count TO 4;
    """.format(username, password))

    conn.commit()


def set_password(host, username, password):
    """
    Set a user's password.
    """

    host = _get_host(host)

    conn = psycopg2.connect(
        host=host,
        database='analytics',
        port=5439,
    )

    cur = conn.cursor()

    cur.execute("""
    ALTER USER {0}
    PASSWORD '{1}';
    """.format(username, password))

    conn.commit()


def dedupe(host, table):
    """
    Remove duplicate entries from *table* on *host* using DISTINCT.

    Uses the slowest of the deep copy methods (temp table + truncate),
    but this avoids dropping the original table, so
    all keys and grants on the original table are preserved.

    See
    http://docs.aws.amazon.com/redshift/latest/dg/performing-a-deep-copy.html
    """

    temptable = "{}_copied".format(table)

    with redshift_transaction(host) as (conn, cur):
        cur.execute("""
        -- make all updates to this table block
        LOCK {table};

        -- CREATE TABLE LIKE copies the dist key
        CREATE TEMP TABLE {temptable} (LIKE {table});

        -- move the data
        INSERT INTO {temptable} SELECT DISTINCT * FROM {table};
        DELETE FROM {table};  -- slower than TRUNCATE, but transaction-safe
        INSERT INTO {table} (SELECT * FROM {temptable});
        DROP TABLE {temptable};
        """.format(table=table, temptable=temptable))
